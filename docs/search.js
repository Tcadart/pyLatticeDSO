window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pyLattice", "modulename": "pyLattice", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyLattice.beam", "modulename": "pyLattice.beam", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyLattice.beam.Beam", "modulename": "pyLattice.beam", "qualname": "Beam", "kind": "class", "doc": "<p>Class Beam represents a beam element defined by two endpoints (Point objects), a radius, material index, type,\nand the cells it belongs to.</p>\n"}, {"fullname": "pyLattice.beam.Beam.__init__", "modulename": "pyLattice.beam", "qualname": "Beam.__init__", "kind": "function", "doc": "<p>Initialize a Beam object representing a beam element.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>point1 : Point\n    The first endpoint of the beam.</p>\n\n<p>point2 : Point\n    The second endpoint of the beam.</p>\n\n<p>radius : float\n    The radius of the beam.</p>\n\n<p>material : int\n    The material index of the beam.</p>\n\n<p>type_beam : int\n    Reference to the geometry type of the beam in case of multiple geometries.</p>\n\n<p>cell_belongings : Cell or list of Cell\n    The cell(s) to which the beam belongs.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">point1</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">point2</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">material</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">type_beam</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">cell_belongings</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">&#39;Cell&#39;</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "pyLattice.beam.Beam.point1", "modulename": "pyLattice.beam", "qualname": "Beam.point1", "kind": "variable", "doc": "<p></p>\n", "annotation": ": pyLattice.point.Point"}, {"fullname": "pyLattice.beam.Beam.point2", "modulename": "pyLattice.beam", "qualname": "Beam.point2", "kind": "variable", "doc": "<p></p>\n", "annotation": ": pyLattice.point.Point"}, {"fullname": "pyLattice.beam.Beam.radius", "modulename": "pyLattice.beam", "qualname": "Beam.radius", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "pyLattice.beam.Beam.material", "modulename": "pyLattice.beam", "qualname": "Beam.material", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "pyLattice.beam.Beam.type_beam", "modulename": "pyLattice.beam", "qualname": "Beam.type_beam", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "pyLattice.beam.Beam.length", "modulename": "pyLattice.beam", "qualname": "Beam.length", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "pyLattice.beam.Beam.volume", "modulename": "pyLattice.beam", "qualname": "Beam.volume", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "pyLattice.beam.Beam.index", "modulename": "pyLattice.beam", "qualname": "Beam.index", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[int]"}, {"fullname": "pyLattice.beam.Beam.angle_point_1", "modulename": "pyLattice.beam", "qualname": "Beam.angle_point_1", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict"}, {"fullname": "pyLattice.beam.Beam.angle_point_2", "modulename": "pyLattice.beam", "qualname": "Beam.angle_point_2", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict"}, {"fullname": "pyLattice.beam.Beam.beam_mod", "modulename": "pyLattice.beam", "qualname": "Beam.beam_mod", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "pyLattice.beam.Beam.penalization_coefficient", "modulename": "pyLattice.beam", "qualname": "Beam.penalization_coefficient", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "pyLattice.beam.Beam.associated_beams_mod", "modulename": "pyLattice.beam", "qualname": "Beam.associated_beams_mod", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[pyLattice.beam.Beam]"}, {"fullname": "pyLattice.beam.Beam.initial_radius", "modulename": "pyLattice.beam", "qualname": "Beam.initial_radius", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[float]"}, {"fullname": "pyLattice.beam.Beam.destroy", "modulename": "pyLattice.beam", "qualname": "Beam.destroy", "kind": "function", "doc": "<p>Delete the beam and clean up references in points and cells.\nThis method removes the beam from its associated cells and points.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.data", "modulename": "pyLattice.beam", "qualname": "Beam.data", "kind": "variable", "doc": "<p>Property to retrieve beam data for exporting.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>List[int]: [beam_index, point1_index, point2_index, beam_type].\n</code></pre>\n", "annotation": ": List[int]"}, {"fullname": "pyLattice.beam.Beam.get_length", "modulename": "pyLattice.beam", "qualname": "Beam.get_length", "kind": "function", "doc": "<p>Calculate the length of the beam.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>float: Length of the beam.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.get_volume", "modulename": "pyLattice.beam", "qualname": "Beam.get_volume", "kind": "function", "doc": "<p>Calculate the volume of the beam in case of a circular section.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>sectionType : str\n    The type of the beam section. Currently only \"circular\" is supported.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>float: Volume of the beam.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">section_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;circular&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.is_identical_to", "modulename": "pyLattice.beam", "qualname": "Beam.is_identical_to", "kind": "function", "doc": "<p>Check if this beam is identical to another beam.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>other : Beam\n    The other beam to compare with.\ntol : float\n    Tolerance for floating-point comparisons.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">beam</span><span class=\"o\">.</span><span class=\"n\">Beam</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-09</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.add_cell_belonging", "modulename": "pyLattice.beam", "qualname": "Beam.add_cell_belonging", "kind": "function", "doc": "<p>Add a cell to the beam's belongings if not already present.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>cell : Cell\n    The cell to add to the beam's belongings.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cell</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">cell</span><span class=\"o\">.</span><span class=\"n\">Cell</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.get_angle_between_beams", "modulename": "pyLattice.beam", "qualname": "Beam.get_angle_between_beams", "kind": "function", "doc": "<p>Calculates the angle between two beams</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>other : Beam\n    The other beam to calculate the angle with.</p>\n\n<p>periodicity : bool\n    If True, considers periodic boundary conditions.</p>\n\n<h2 id=\"return\">Return:</h2>\n\n<p>Angle: float\n    angle in degrees</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">beam</span><span class=\"o\">.</span><span class=\"n\">Beam</span>, </span><span class=\"param\"><span class=\"n\">periodicity</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.get_point_on_beam_at_distance", "modulename": "pyLattice.beam", "qualname": "Beam.get_point_on_beam_at_distance", "kind": "function", "doc": "<p>Calculate the coordinates of a point on the beam at a specific distance from an endpoint.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>distance : float\n    The distance from the specified endpoint along the beam.</p>\n\n<p>start_point : int\n    The index of the starting point (1 or 2) from which the distance is measured</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>List[float]: Coordinates [x, y, z] of the calculated point.\n</code></pre>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<pre><code>ValueError: If the point index is not 1 or 2.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">distance</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">start_point</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.is_point_on_beam", "modulename": "pyLattice.beam", "qualname": "Beam.is_point_on_beam", "kind": "function", "doc": "<p>Check if a given node lies on the beam.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>node : Point\n    The node to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>bool: True if the node lies on the beam, False otherwise.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.set_angle", "modulename": "pyLattice.beam", "qualname": "Beam.set_angle", "kind": "function", "doc": "<p>Assign angle and radius data to one of the beam's endpoints.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>radius : float\n    Radius at the point.</p>\n\n<p>angle : float\n    Angle at the point in degrees.</p>\n\n<p>point : Point\n    The point (endpoint) of the beam to which the data is assigned.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">point</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.get_length_mod", "modulename": "pyLattice.beam", "qualname": "Beam.get_length_mod", "kind": "function", "doc": "<p>Calculate the modification length for the penalization method.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>Tuple[float, float]: Length modifications for point1 and point2.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.set_beam_mod", "modulename": "pyLattice.beam", "qualname": "Beam.set_beam_mod", "kind": "function", "doc": "<p>Set the beam as modified.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.unset_beam_mod", "modulename": "pyLattice.beam", "qualname": "Beam.unset_beam_mod", "kind": "function", "doc": "<p>Unset the beam as modified.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.beam.Beam.change_beam_radius", "modulename": "pyLattice.beam", "qualname": "Beam.change_beam_radius", "kind": "function", "doc": "<p>Change the radius of the beam.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>new_radius : float\n    The new radius to set for the beam.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">new_radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell", "modulename": "pyLattice.cell", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyLattice.cell.Cell", "modulename": "pyLattice.cell", "qualname": "Cell", "kind": "class", "doc": "<p>Class representing a cell in the lattice structure.</p>\n"}, {"fullname": "pyLattice.cell.Cell.__init__", "modulename": "pyLattice.cell", "qualname": "Cell.__init__", "kind": "function", "doc": "<p>Initialize a Cell with its dimensions and position</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>pos: list\n    Position of the cell in the lattice</p>\n\n<p>initial_cell_size: list\n    Initial size of the cell</p>\n\n<p>coordinate: list\n    Coordinates of the cell minimum corner in the lattice</p>\n\n<p>geom_types: list[str]\n    Type of lattice geometry</p>\n\n<p>radii: float\n    Base radii of the beam</p>\n\n<p>grad_radius: list\n    Gradient of the radii</p>\n\n<p>grad_dim: list\n    Gradient of the dimensions</p>\n\n<p>grad_mat: list\n    Gradient of the material</p>\n\n<p>uncertainty_node: float\n    Standard deviation for adding uncertainty to node coordinates. Defaults to 0.0.</p>\n\n<p>_verbose: bool\n    If True, prints additional information during initialization. Defaults to False.</p>\n\n<p>beams_already_defined: set\n    Set of beams already defined in the lattice to avoid duplication. Defaults to None.</p>\n\n<p>nodes_already_defined: set\n    Set of nodes already defined in the lattice to avoid duplication. Defaults to None.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pos</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">initial_size</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">coordinate</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">geom_types</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">radii</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">grad_radius</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">grad_dim</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">grad_mat</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">uncertainty_node</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">_verbose</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">beams_already_defined</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nodes_already_defined</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "pyLattice.cell.Cell.original_cell_geom", "modulename": "pyLattice.cell", "qualname": "Cell.original_cell_geom", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.cell.Cell.original_tags", "modulename": "pyLattice.cell", "qualname": "Cell.original_tags", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.cell.Cell.center_point", "modulename": "pyLattice.cell", "qualname": "Cell.center_point", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.cell.Cell.beam_material", "modulename": "pyLattice.cell", "qualname": "Cell.beam_material", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.cell.Cell.size", "modulename": "pyLattice.cell", "qualname": "Cell.size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.cell.Cell.pos", "modulename": "pyLattice.cell", "qualname": "Cell.pos", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[int]"}, {"fullname": "pyLattice.cell.Cell.coordinate", "modulename": "pyLattice.cell", "qualname": "Cell.coordinate", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[float]"}, {"fullname": "pyLattice.cell.Cell.beams_cell", "modulename": "pyLattice.cell", "qualname": "Cell.beams_cell", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[set]"}, {"fullname": "pyLattice.cell.Cell.points_cell", "modulename": "pyLattice.cell", "qualname": "Cell.points_cell", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[set]"}, {"fullname": "pyLattice.cell.Cell.index", "modulename": "pyLattice.cell", "qualname": "Cell.index", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[int]"}, {"fullname": "pyLattice.cell.Cell.geom_types", "modulename": "pyLattice.cell", "qualname": "Cell.geom_types", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[str]"}, {"fullname": "pyLattice.cell.Cell.radii", "modulename": "pyLattice.cell", "qualname": "Cell.radii", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[float]"}, {"fullname": "pyLattice.cell.Cell.coupling_matrix_B", "modulename": "pyLattice.cell", "qualname": "Cell.coupling_matrix_B", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional"}, {"fullname": "pyLattice.cell.Cell.uncertainty_node", "modulename": "pyLattice.cell", "qualname": "Cell.uncertainty_node", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "pyLattice.cell.Cell.grad_radius", "modulename": "pyLattice.cell", "qualname": "Cell.grad_radius", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list"}, {"fullname": "pyLattice.cell.Cell.grad_mat", "modulename": "pyLattice.cell", "qualname": "Cell.grad_mat", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list"}, {"fullname": "pyLattice.cell.Cell.grad_dim", "modulename": "pyLattice.cell", "qualname": "Cell.grad_dim", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list"}, {"fullname": "pyLattice.cell.Cell.neighbour_cells", "modulename": "pyLattice.cell", "qualname": "Cell.neighbour_cells", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict"}, {"fullname": "pyLattice.cell.Cell.schur_complement", "modulename": "pyLattice.cell", "qualname": "Cell.schur_complement", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[list[float]]"}, {"fullname": "pyLattice.cell.Cell.schur_complement_gradient", "modulename": "pyLattice.cell", "qualname": "Cell.schur_complement_gradient", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[list[float]]"}, {"fullname": "pyLattice.cell.Cell.node_in_order_simulation", "modulename": "pyLattice.cell", "qualname": "Cell.node_in_order_simulation", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[List[pyLattice.point.Point]]"}, {"fullname": "pyLattice.cell.Cell.dispose", "modulename": "pyLattice.cell", "qualname": "Cell.dispose", "kind": "function", "doc": "<p>Dispose of the cell by detaching beams and points, and cleaning up references.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.volume", "modulename": "pyLattice.cell", "qualname": "Cell.volume", "kind": "variable", "doc": "<p>Calculate the volume of the cell.</p>\n"}, {"fullname": "pyLattice.cell.Cell.relative_density", "modulename": "pyLattice.cell", "qualname": "Cell.relative_density", "kind": "variable", "doc": "<p>Calculate the relative density of the cell based on the volume of beams and the cell volume.</p>\n", "annotation": ": float"}, {"fullname": "pyLattice.cell.Cell.volume_each_geom", "modulename": "pyLattice.cell", "qualname": "Cell.volume_each_geom", "kind": "variable", "doc": "<p>Get the volume of the cell separated by geometry type_beam.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "pyLattice.cell.Cell.boundary_box", "modulename": "pyLattice.cell", "qualname": "Cell.boundary_box", "kind": "variable", "doc": "<p>Get the boundary box of the cell</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>list\n    List of the boundary box coordinates</p>\n", "annotation": ": list"}, {"fullname": "pyLattice.cell.Cell.boundary_edges", "modulename": "pyLattice.cell", "qualname": "Cell.boundary_edges", "kind": "variable", "doc": "<p>Return the 12 edge segments of the cell's axis-aligned bounding box\nas pairs of 3D points ((x,y,z), (x,y,z)).</p>\n", "annotation": ": list[tuple[tuple[float, float, float], tuple[float, float, float]]]"}, {"fullname": "pyLattice.cell.Cell.corner_coordinates", "modulename": "pyLattice.cell", "qualname": "Cell.corner_coordinates", "kind": "variable", "doc": "<p>Get the corner coordinates of the cell.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>list of tuples\n    List of (x, y, z) coordinates of the corner points.</p>\n", "annotation": ": list"}, {"fullname": "pyLattice.cell.Cell.generate_cell_properties", "modulename": "pyLattice.cell", "qualname": "Cell.generate_cell_properties", "kind": "function", "doc": "<p>Generate cell properties including beams and nodes.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>initialCellSize: list\n    Initial size of the cell without modification</p>\n\n<p>beams_already_defined: set\n    Set of beams already defined in the lattice to avoid duplication</p>\n\n<p>nodes_already_defined: set\n    Set of nodes already defined in the lattice to avoid duplication</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">initial_cell_size</span>,</span><span class=\"param\">\t<span class=\"n\">beams_already_defined</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">set</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nodes_already_defined</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">set</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.generate_beams", "modulename": "pyLattice.cell", "qualname": "Cell.generate_beams", "kind": "function", "doc": "<p>Generate beams and nodes using a given lattice type_beam and parameters.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>latticeType: str\n    Type of lattice structure (e.g., 'BCC', 'Hybrid1', etc.)</p>\n\n<p>beamRadius: float\n    Radius of the beam</p>\n\n<p>beamType: int\n    Type index of the beam</p>\n\n<p>beams_already_defined: set\n    Set of beams already defined in the lattice to avoid duplication</p>\n\n<p>nodes_already_defined: set\n    Set of nodes already defined in the lattice to avoid duplication</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">latticeType</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">beamRadius</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">beamType</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">beams_already_defined</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nodes_already_defined</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_beam_material", "modulename": "pyLattice.cell", "qualname": "Cell.get_beam_material", "kind": "function", "doc": "<p>Get the material of the beam based on the material gradient.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_radius", "modulename": "pyLattice.cell", "qualname": "Cell.get_radius", "kind": "function", "doc": "<p>Calculate and return the beam radii</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>baseRadius: float\n    Base radius of the beam</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>beamRadius : float\n    Calculated beam radii</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">base_radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.def_cell_size", "modulename": "pyLattice.cell", "qualname": "Cell.def_cell_size", "kind": "function", "doc": "<p>Calculate and return the cell size</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>initial_cell_size: list\n    Initial size of the cell</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">initial_cell_size</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.def_cell_center", "modulename": "pyLattice.cell", "qualname": "Cell.def_cell_center", "kind": "function", "doc": "<p>Calculate the center point of the cell</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_point_on_surface", "modulename": "pyLattice.cell", "qualname": "Cell.get_point_on_surface", "kind": "function", "doc": "<p>Get the points on the surface specified in the global reference frame.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>surfaceName: str\n    Name of the surface. Choose from 'Xmin', 'Xmax', 'Ymin', 'Ymax', 'Zmin', 'Zmax', 'Xmid', 'Ymid', 'Zmid'.\n    If 'Xmid', 'Ymid', or 'Zmid' is specified, it returns the points at the bottom of the cell</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>list\n   List of points on the specified surface.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">surfaceName</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.remove_beam", "modulename": "pyLattice.cell", "qualname": "Cell.remove_beam", "kind": "function", "doc": "<p>Removing beam from cell</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>beam_to_delete: Beam or Iterable[Beam]\n    Beam or list of beams to remove from the cell</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">beam_to_delete</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">beam</span><span class=\"o\">.</span><span class=\"n\">Beam</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">beam</span><span class=\"o\">.</span><span class=\"n\">Beam</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.remove_point", "modulename": "pyLattice.cell", "qualname": "Cell.remove_point", "kind": "function", "doc": "<p>Removing point from cell</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>point_to_delete: Point or Iterable[Point]\n    Point or list of points to remove from the cell</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">point_to_delete</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.add_beam", "modulename": "pyLattice.cell", "qualname": "Cell.add_beam", "kind": "function", "doc": "<p>Adding beam to cell</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>beam_to_add: Beam or Iterable[Beam]\n    Beam or list of beams to add to the cell</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">beam_to_add</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">beam</span><span class=\"o\">.</span><span class=\"n\">Beam</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">beam</span><span class=\"o\">.</span><span class=\"n\">Beam</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.add_point", "modulename": "pyLattice.cell", "qualname": "Cell.add_point", "kind": "function", "doc": "<p>Adding point to cell</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>point_to_add: Point or Iterable[Point]\n    Point or list of points to add to the cell</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">point_to_add</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.add_cell_neighbour", "modulename": "pyLattice.cell", "qualname": "Cell.add_cell_neighbour", "kind": "function", "doc": "<p>Add a neighbour cell in a structured dict format.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>direction : str\n    One of \"x\", \"y\", \"z\"\nsign : str\n    Either \"positif\" or \"negatif\"\nneighbour_cell : Cell\n    Neighbour cell to add</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">sign</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">neighbour_cell</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">cell</span><span class=\"o\">.</span><span class=\"n\">Cell</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_all_cell_neighbours", "modulename": "pyLattice.cell", "qualname": "Cell.get_all_cell_neighbours", "kind": "function", "doc": "<p>Get all neighbour cells in a flat list.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>list of Cell\n    List of all neighbour cells</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">cell</span><span class=\"o\">.</span><span class=\"n\">Cell</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.refresh_from_global", "modulename": "pyLattice.cell", "qualname": "Cell.refresh_from_global", "kind": "function", "doc": "<p>Rebuild self.beams_cell and self.points_cell from the current lattice state.\nKeeps only beams that still declare this cell as a belonging, and derives points from those beams.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">all_beams</span><span class=\"p\">:</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">beam</span><span class=\"o\">.</span><span class=\"n\">Beam</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.define_node_order_to_simulate", "modulename": "pyLattice.cell", "qualname": "Cell.define_node_order_to_simulate", "kind": "function", "doc": "<p>Define a deterministic order for boundary nodes to ensure consistent simulation results.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>face_priority: Optional[List[str]]\n    List defining the priority order of faces to assign nodes to when they lie on multiple faces.\n    Default is [\"Xmin\", \"Xmax\", \"Ymin\", \"Ymax\", \"Zmin\", \"Zmax\"].</p>\n\n<p>tol: float\n    Tolerance for determining if a point lies on a face. Default is 1e-9.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">face_priority</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-09</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.set_reaction_force_on_nodes", "modulename": "pyLattice.cell", "qualname": "Cell.set_reaction_force_on_nodes", "kind": "function", "doc": "<p>Set reaction force on each boundary node in the established local order.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>reactionForce: list\n    List of reaction force vectors corresponding to each boundary node.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">reactionForce</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_displacement_at_nodes", "modulename": "pyLattice.cell", "qualname": "Cell.get_displacement_at_nodes", "kind": "function", "doc": "<p>Return displacement vectors ordered consistently with the provided local list/dict of Points.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>nodeList: list or OrderedDict\n    List or OrderedDict of Point objects representing the nodes.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>list\n    List of displacement vectors for the nodes.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">nodeList</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">],</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">OrderedDict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.set_displacement_at_boundary_nodes", "modulename": "pyLattice.cell", "qualname": "Cell.set_displacement_at_boundary_nodes", "kind": "function", "doc": "<p>Set displacement at nodes.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>displacementArray: list or array-like\n    Flattened array of displacement values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">displacementArray</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.build_coupling_operator", "modulename": "pyLattice.cell", "qualname": "Cell.build_coupling_operator", "kind": "function", "doc": "<p>Build the coupling operator B using the deterministic local boundary-node order.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>nb_free_DOF: int\n    Total number of free degrees of freedom in the global system.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">nb_free_DOF</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.build_local_preconditioner", "modulename": "pyLattice.cell", "qualname": "Cell.build_local_preconditioner", "kind": "function", "doc": "<p>Build the local preconditioner matrix B^T * S * B</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>schur_mean: array-like or None\n    Schur complement matrix to use. If None, uses self.schur_complement.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">schur_mean</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_number_boundary_nodes", "modulename": "pyLattice.cell", "qualname": "Cell.get_number_boundary_nodes", "kind": "function", "doc": "<p>Get the number of unique boundary nodes in the cell.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_internal_energy", "modulename": "pyLattice.cell", "qualname": "Cell.get_internal_energy", "kind": "function", "doc": "<p>Get cell internal energy from all boundary points</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_displacement_data", "modulename": "pyLattice.cell", "qualname": "Cell.get_displacement_data", "kind": "function", "doc": "<p>Build and return displacement data on cell for dataset generation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_number_nodes_at_boundary", "modulename": "pyLattice.cell", "qualname": "Cell.get_number_nodes_at_boundary", "kind": "function", "doc": "<p>Get the number of nodes at the boundary</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>int\n    Number of nodes at the boundary</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.change_beam_radius", "modulename": "pyLattice.cell", "qualname": "Cell.change_beam_radius", "kind": "function", "doc": "<p>WARNING: BEAM MOD IS NOT WORKING\nChange beam radii in the cell</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>newRadius: list\n    beam radii wanted to assign</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">new_radius</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_relative_density_kriging", "modulename": "pyLattice.cell", "qualname": "Cell.get_relative_density_kriging", "kind": "function", "doc": "<p>Get the relative density of the cell using kriging model</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>krigingModel: Kriging\n    Kriging model to use for prediction</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">kriging_model</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_relative_density_gradient", "modulename": "pyLattice.cell", "qualname": "Cell.get_relative_density_gradient", "kind": "function", "doc": "<p>Get the gradient of the relative density</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>relative_density_poly_deriv: list\n    List of polynomial derivative functions</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>deriv: float\n    Derivative of the relative density</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">relative_density_poly_deriv</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_relative_density_gradient_kriging", "modulename": "pyLattice.cell", "qualname": "Cell.get_relative_density_gradient_kriging", "kind": "function", "doc": "<p>Finite difference gradient of the relative density (predictive mean) w.r.t. the radii using the trained\nPipeline(StandardScaler -> GaussianProcessRegressor) with Constant*RBF kernel.\nReturns an array of size len(geometries_types) where entries for geometries not present in the cell are 0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">model</span>, </span><span class=\"param\"><span class=\"n\">geometries_types</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_relative_density_gradient_kriging_exact", "modulename": "pyLattice.cell", "qualname": "Cell.get_relative_density_gradient_kriging_exact", "kind": "function", "doc": "<p>Exact gradient of the relative density (predictive mean) w.r.t. the radii using the trained\nPipeline(StandardScaler -> GaussianProcessRegressor) with Constant*RBF kernel.</p>\n\n<p>Returns an array of size len(geometries_types) where entries for geometries not present in the cell are 0.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>model: Pipeline\n    Trained kriging model</p>\n\n<p>geometries_types: list\n    List of geometry types in the trained kriging model</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">model</span>, </span><span class=\"param\"><span class=\"n\">geometries_types</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_RGBcolor_depending_of_radius", "modulename": "pyLattice.cell", "qualname": "Cell.get_RGBcolor_depending_of_radius", "kind": "function", "doc": "<p>Get the RGB color of the cell depending on the radii.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.print_data", "modulename": "pyLattice.cell", "qualname": "Cell.print_data", "kind": "function", "doc": "<p>Print the data of the cell for debugging purposes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_translation_rigid_body", "modulename": "pyLattice.cell", "qualname": "Cell.get_translation_rigid_body", "kind": "function", "doc": "<p>Get the translation of the rigid body</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.cell.Cell.get_rotation_rigid_body", "modulename": "pyLattice.cell", "qualname": "Cell.get_rotation_rigid_body", "kind": "function", "doc": "<p>Get the rotation matrix of the rigid body using SVD.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.design_transformation", "modulename": "pyLattice.design_transformation", "kind": "module", "doc": "<p>List of functions to transform the lattice structure in different ways.</p>\n\n<p>These functions can be used to modify the lattice geometry, such as attracting points, curving the lattice, \napplying cylindrical transformations, and fitting to surfaces.</p>\n"}, {"fullname": "pyLattice.design_transformation.attractor_lattice", "modulename": "pyLattice.design_transformation", "qualname": "attractor_lattice", "kind": "function", "doc": "<p>Attract lattice to a specific point</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>PointAttractor: list of float in dim 3\n    Coordinates of the attractor point (default: None)</p>\n\n<p>alpha: float\n    Coefficient of attraction (default: 0.5)</p>\n\n<p>inverse: bool\n    If True, points farther away are attracted less (default: False)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">lattice</span>,</span><span class=\"param\">\t<span class=\"n\">PointAttractorList</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">inverse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.design_transformation.curveLattice", "modulename": "pyLattice.design_transformation", "qualname": "curveLattice", "kind": "function", "doc": "<p>Curve the lattice structure around a given center.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>center_x: float\n    The x-coordinate of the center of the curvature.</p>\n\n<p>center_y: float\n    The y-coordinate of the center of the curvature.</p>\n\n<p>center_z: float\n    The z-coordinate of the center of the curvature.</p>\n\n<p>curvature_strength: float (default: 0.1)\n    The strength of the curvature applied to the lattice.\n    Positive values curve upwards, negative values curve downwards.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">lattice</span>,</span><span class=\"param\">\t<span class=\"n\">center_x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">center_y</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">center_z</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">curvature_strength</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.design_transformation.cylindrical_transform", "modulename": "pyLattice.design_transformation", "qualname": "cylindrical_transform", "kind": "function", "doc": "<p>Apply cylindrical transformation to the lattice structure.\nTo create stent structures, 1 cell in the X direction is required and you can choose any number of cells in\nthe Y and Z direction.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>radii: float\n    radii of the cylinder.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lattice</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.design_transformation.moveToCylinderForm", "modulename": "pyLattice.design_transformation", "qualname": "moveToCylinderForm", "kind": "function", "doc": "<p>Move the lattice to a cylindrical form.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>radii: float\n    radii of the cylinder.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lattice</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.design_transformation.fitToSurface", "modulename": "pyLattice.design_transformation", "qualname": "fitToSurface", "kind": "function", "doc": "<p>Adjust the lattice nodes to follow a surface defined by an equation.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>equation : callable\n    Function representing the surface. For example, a lambda function or a normal function.\n    Example: lambda x, y: x<strong>2 + y</strong>2 (for a paraboloid).</p>\n\n<p>mode : str\n    Adjustment mode:\n    - \"z\": Adjust nodes on a surface (z = f(x, y)).\n    - \"z_plan\": Adjust nodes on a plan (z = f(x, y)) without changing the z-coordinate.</p>\n\n<p>params : dict\n    Additional parameters for the equation or mode (e.g., radii, angle, etc.).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">lattice</span>,</span><span class=\"param\">\t<span class=\"n\">equation</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">callable</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;z&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.gradient_properties", "modulename": "pyLattice.gradient_properties", "kind": "module", "doc": "<p>Gradient properties module.</p>\n"}, {"fullname": "pyLattice.gradient_properties.grad_settings_constant", "modulename": "pyLattice.gradient_properties", "qualname": "grad_settings_constant", "kind": "function", "doc": "<p>Generate constant gradient settings (i.e., all values = 1.0).</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>num_cells_x : int\n    Number of cells in the x-direction.</p>\n\n<p>num_cells_y : int\n    Number of cells in the y-direction.</p>\n\n<p>num_cells_z : int\n    Number of cells in the z-direction.</p>\n\n<p>material_gradient : bool\n    If True, return a 3D list for material gradient; otherwise, return a flat list.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>list[list[float]]:\n    A list of [1.0, 1.0, 1.0] repeated for the total number of cells.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">num_cells_x</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">num_cells_y</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">num_cells_z</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">material_gradient</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.gradient_properties.get_grad_settings", "modulename": "pyLattice.gradient_properties", "qualname": "get_grad_settings", "kind": "function", "doc": "<p>Generate gradient settings based on the provided rule, direction, and parameters.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>num_cells_x : int\n    Number of cells in the x-direction.</p>\n\n<p>num_cells_y : int\n    Number of cells in the y-direction.</p>\n\n<p>num_cells_z : int\n    Number of cells in the z-direction.</p>\n\n<p>gradProperties: list[Rule, Direction, Parameters]\n    All types of properties for gradient definition.</p>\n\n<h2 id=\"return\">Return:</h2>\n\n<p>gradientData: list[list[float]]\n    Generated gradient settings (list of lists).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">num_cells_x</span>,</span><span class=\"param\">\t<span class=\"n\">num_cells_y</span>,</span><span class=\"param\">\t<span class=\"n\">num_cells_z</span>,</span><span class=\"param\">\t<span class=\"n\">grad_properties</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.gradient_properties.grad_material_setting", "modulename": "pyLattice.gradient_properties", "qualname": "grad_material_setting", "kind": "function", "doc": "<p>Define gradient material settings.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>gradMatProperty: list[Multimat, GradMaterialDirection]\n    Set of properties for material gradient.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>grad_mat: list\n    3D list representing the material type_beam in the structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">numCellsX</span>, </span><span class=\"param\"><span class=\"n\">numCellsY</span>, </span><span class=\"param\"><span class=\"n\">numCellsZ</span>, </span><span class=\"param\"><span class=\"n\">gradMatProperty</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice", "modulename": "pyLattice.lattice", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice", "modulename": "pyLattice.lattice", "qualname": "Lattice", "kind": "class", "doc": "<p>Class to generate lattice structures with various parameters and properties.</p>\n"}, {"fullname": "pyLattice.lattice.Lattice.__init__", "modulename": "pyLattice.lattice", "qualname": "Lattice.__init__", "kind": "function", "doc": "<p>Constructor from a JSON file to create a lattice object.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>name_file: str\n    Name of the JSON file containing lattice parameters.</p>\n\n<p>mesh_trimmer: MeshTrimmer, optional\n    MeshTrimmer object to trim the lattice.</p>\n\n<p>_verbose: int, optional\n    Verbosity level for logging.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">mesh_trimmer</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span>)</span>"}, {"fullname": "pyLattice.lattice.Lattice.mesh_trimmer", "modulename": "pyLattice.lattice", "qualname": "Lattice.mesh_trimmer", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.timing", "modulename": "pyLattice.lattice", "qualname": "Lattice.timing", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.name_lattice", "modulename": "pyLattice.lattice", "qualname": "Lattice.name_lattice", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "pyLattice.lattice.Lattice.radii", "modulename": "pyLattice.lattice", "qualname": "Lattice.radii", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.geom_types", "modulename": "pyLattice.lattice", "qualname": "Lattice.geom_types", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.enable_randomness", "modulename": "pyLattice.lattice", "qualname": "Lattice.enable_randomness", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.randomness_hybrid", "modulename": "pyLattice.lattice", "qualname": "Lattice.randomness_hybrid", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.range_radius", "modulename": "pyLattice.lattice", "qualname": "Lattice.range_radius", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.symmetry_lattice", "modulename": "pyLattice.lattice", "qualname": "Lattice.symmetry_lattice", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.uncertainty_node", "modulename": "pyLattice.lattice", "qualname": "Lattice.uncertainty_node", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.eraser_blocks", "modulename": "pyLattice.lattice", "qualname": "Lattice.eraser_blocks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.enable_periodicity", "modulename": "pyLattice.lattice", "qualname": "Lattice.enable_periodicity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.enable_simulation_properties", "modulename": "pyLattice.lattice", "qualname": "Lattice.enable_simulation_properties", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.cells", "modulename": "pyLattice.lattice", "qualname": "Lattice.cells", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.beams", "modulename": "pyLattice.lattice", "qualname": "Lattice.beams", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.nodes", "modulename": "pyLattice.lattice", "qualname": "Lattice.nodes", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.edge_tags", "modulename": "pyLattice.lattice", "qualname": "Lattice.edge_tags", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.face_tags", "modulename": "pyLattice.lattice", "qualname": "Lattice.face_tags", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.corner_tags", "modulename": "pyLattice.lattice", "qualname": "Lattice.corner_tags", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.lattice_dimension_dict", "modulename": "pyLattice.lattice", "qualname": "Lattice.lattice_dimension_dict", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.occupancy_matrix", "modulename": "pyLattice.lattice", "qualname": "Lattice.occupancy_matrix", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.mesh_lattice", "modulename": "pyLattice.lattice", "qualname": "Lattice.mesh_lattice", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.lattice.Lattice.open_pickle_lattice", "modulename": "pyLattice.lattice", "qualname": "Lattice.open_pickle_lattice", "kind": "function", "doc": "<p>Load a lattice pickle and (optionally) upcast it to the caller's class (e.g., LatticeSim).\nIf the target class defines <code>_post_load_init</code>, it will be invoked after loading.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;LatticeObject&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">sim_config</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">lattice</span><span class=\"o\">.</span><span class=\"n\">Lattice</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_number_cells", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_number_cells", "kind": "function", "doc": "<p>Get number of cells in the lattice</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_number_beams", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_number_beams", "kind": "function", "doc": "<p>Get number of beams in the lattice</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_number_nodes", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_number_nodes", "kind": "function", "doc": "<p>Get number of nodes in the lattice</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.extract_parameters_from_json", "modulename": "pyLattice.lattice", "qualname": "Lattice.extract_parameters_from_json", "kind": "function", "doc": "<p>Extract lattice parameters from a JSON file and set the corresponding attributes.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>name_file: str\n    Name of the JSON file containing lattice parameters.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_lattice_boundary_box", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_lattice_boundary_box", "kind": "function", "doc": "<p>Get the boundary box of the lattice</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.define_lattice_dimensions", "modulename": "pyLattice.lattice", "qualname": "Lattice.define_lattice_dimensions", "kind": "function", "doc": "<p>Computes extremum values of coordinates in the lattice.</p>\n\n<h2 id=\"return\">Return:</h2>\n\n<p>lattice_dimension_dict: dict\n    Dictionary containing min and max values for x, y, z coordinates.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_relative_density", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_relative_density", "kind": "function", "doc": "<p>Get mean relative density of all cells in lattice\nSimple average of cell relative densities</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>meanRelDens: float\n    Mean relative density of the lattice</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_beam_radius_min_max", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_beam_radius_min_max", "kind": "function", "doc": "<p>Get the maximum and minimum radii of the lattice</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>radMax: float\n    Maximum radii of the lattice</p>\n\n<p>radMin: float\n    Minimum radii of the lattice</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.define_gradient", "modulename": "pyLattice.lattice", "qualname": "Lattice.define_gradient", "kind": "function", "doc": "<p>Define gradient settings for radii, dimensions, and materials based on provided properties.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>grad_radius_property: list\n    Properties defining the gradient for radii.</p>\n\n<p>grad_dim_property: list\n    Properties defining the gradient for cell dimensions.</p>\n\n<p>grad_mat_property: list\n    Properties defining the gradient for material settings.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">grad_radius_property</span>, </span><span class=\"param\"><span class=\"n\">grad_dim_property</span>, </span><span class=\"param\"><span class=\"n\">grad_mat_property</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.generate_lattice", "modulename": "pyLattice.lattice", "qualname": "Lattice.generate_lattice", "kind": "function", "doc": "<p>Generate cells in the lattice structure based on cell size, number of cells, geometry types, and radii.\nGradient information and erased regions are also considered during cell generation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.cut_beam_with_mesh_trimmer", "modulename": "pyLattice.lattice", "qualname": "Lattice.cut_beam_with_mesh_trimmer", "kind": "function", "doc": "<p>Cut beams in the lattice using the mesh trimmer.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.apply_symmetry", "modulename": "pyLattice.lattice", "qualname": "Lattice.apply_symmetry", "kind": "function", "doc": "<p>Apply symmetry to the lattice by mirroring cells across a specified plane.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>symmetry_plane: str, optional\n    Plane of symmetry ('XY', 'XZ', 'YZ', 'X', 'Y',\n    or 'Z'). If None, uses self.symmetry_lattice['sym_plane'].</p>\n\n<p>reference_point: tuple of float, optional\n    Reference point for the symmetry operation (x_ref, y_ref, z_ref).\n    If None, uses self.symmetry_lattice['sym_point'].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">symmetry_plane</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">reference_point</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.delete_beams_under_radius_threshold", "modulename": "pyLattice.lattice", "qualname": "Lattice.delete_beams_under_radius_threshold", "kind": "function", "doc": "<p>Delete beams with radii under a certain threshold</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>threshold: float\n    Threshold value for beam radii</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.set_tag_classification", "modulename": "pyLattice.lattice", "qualname": "Lattice.set_tag_classification", "kind": "function", "doc": "<p>Define tag list classification.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.define_size_lattice", "modulename": "pyLattice.lattice", "qualname": "Lattice.define_size_lattice", "kind": "function", "doc": "<p>Computes the size of the lattice along each direction.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.is_not_in_erased_region", "modulename": "pyLattice.lattice", "qualname": "Lattice.is_not_in_erased_region", "kind": "function", "doc": "<p>Check if the cell is not in the erased region or inside the mesh.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>startCellPos: list of float\n    (xStart, yStart, zStart) position of the cell to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>bool:\n    True if the cell should be removed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start_cell_pos</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.define_beam_node_index", "modulename": "pyLattice.lattice", "qualname": "Lattice.define_beam_node_index", "kind": "function", "doc": "<p>Define index at each beam and node</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.define_cell_index", "modulename": "pyLattice.lattice", "qualname": "Lattice.define_cell_index", "kind": "function", "doc": "<p>Define index at each cell</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.define_node_local_tags", "modulename": "pyLattice.lattice", "qualname": "Lattice.define_node_local_tags", "kind": "function", "doc": "<p>Define inside cell boundary tag for all boundary nodes</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.define_cell_neighbours", "modulename": "pyLattice.lattice", "qualname": "Lattice.define_cell_neighbours", "kind": "function", "doc": "<p>Neighbour assignment using integer grid indices + optional periodic wrap.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.define_connected_beams_for_all_nodes", "modulename": "pyLattice.lattice", "qualname": "Lattice.define_connected_beams_for_all_nodes", "kind": "function", "doc": "<p>Populate <code>Point.connected_beams</code> for all nodes.\nOptionally merges connectivity for coincident/periodic nodes via a spatial hash.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>merge_tol : float\n    Quantization used to bucket nearly-identical coordinates (and periodic wraps).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">merge_tol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-09</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.define_angles_between_beams", "modulename": "pyLattice.lattice", "qualname": "Lattice.define_angles_between_beams", "kind": "function", "doc": "<p>Compute, for each beam, the penalization-optimal angle at its two endpoints\nusing node-level connectivity (Point.connected_beams). Assumes\n<code>define_connected_beams_for_all_nodes()</code> has been called.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.refresh_cells_memberships", "modulename": "pyLattice.lattice", "qualname": "Lattice.refresh_cells_memberships", "kind": "function", "doc": "<p>Public helper to refresh all cells' beams/points from the current global state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.remove_cell", "modulename": "pyLattice.lattice", "qualname": "Lattice.remove_cell", "kind": "function", "doc": "<p>Removes a cell from the lattice</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>index: int\n    index of the cell to remove</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.find_minimum_beam_length", "modulename": "pyLattice.lattice", "qualname": "Lattice.find_minimum_beam_length", "kind": "function", "doc": "<p>Find minimum beam length</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>minLength: float\n    Length of the smallest beam in the lattice</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_tag_list", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_tag_list", "kind": "function", "doc": "<p>Get the tag for all unique points in the lattice.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_tag_list_boundary", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_tag_list_boundary", "kind": "function", "doc": "<p>Get the tag for boundary points in the lattice.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.apply_tag_all_point", "modulename": "pyLattice.lattice", "qualname": "Lattice.apply_tag_all_point", "kind": "function", "doc": "<p>Assign a tag to all nodes in the lattice structure.\nTags are assigned relative to either the global bounding box\nor a local (cell-relative) bounding box if erased parts are used.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_cell_occupancy_matrix", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_cell_occupancy_matrix", "kind": "function", "doc": "<p>Build a 3D matrix storing Cell objects (or None) at each (i, j, k).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>occupancy_matrix : np.ndarray, shape (num_cells_x, num_cells_y, num_cells_z), dtype=object\n    occupancy_matrix[i, j, k] is the Cell at that grid position, or None if empty.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_cells_at_index", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_cells_at_index", "kind": "function", "doc": "<p>Get all cells at a specific index along a specified axis.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>axis: str\n    Axis to query ('x', 'y', or 'z').</p>\n\n<p>index: int\n    Index along the specified axis.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_relative_boundary_box", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_relative_boundary_box", "kind": "function", "doc": "<p>Get the relative boundary box of a cell in the lattice.\nIt corresponds to the minimum and maximum dimension of the lattice for each axis with cell continuity.\nUseful for structures with erased parts or periodic boundaries.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>cell: Cell object\n    The cell for which the boundary box is computed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cell</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_name_lattice", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_name_lattice", "kind": "function", "doc": "<p>Determine the name_lattice of the lattice\nWARNING: not updated</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>name_lattice: string</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.check_hybrid_collision", "modulename": "pyLattice.lattice", "qualname": "Lattice.check_hybrid_collision", "kind": "function", "doc": "<p>Check if beam in hybrid configuration is cut by a point in the geometry\nChange the beam configuration of collisionned beams</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.are_cells_identical", "modulename": "pyLattice.lattice", "qualname": "Lattice.are_cells_identical", "kind": "function", "doc": "<p>Check if all cells in the lattice are identical.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.change_beam_radius", "modulename": "pyLattice.lattice", "qualname": "Lattice.change_beam_radius", "kind": "function", "doc": "<p>Change beam radius for all beams in the lattice\nradius_list must have the same length as the number of different beam types in cells</p>\n\n<p>Take care if penalization is activated, the radius of penalized beams will be modified with the\npenalization coefficient but the length of the modified beam will not be changed\n(Use reset_cell_with_new_radii instead if you want to have clean cells for simulation)</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>radius_list: list of float\n    List of new radii for each beam type</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">radius_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.change_beam_radius_depending_type", "modulename": "pyLattice.lattice", "qualname": "Lattice.change_beam_radius_depending_type", "kind": "function", "doc": "<p>Change radii of beam for specific type_beam</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>typeToChange: int\n    Type of beam to change\nnewRadius: float\n    New radii of beam</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">typeToChange</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">newRadius</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.find_point_on_lattice_surface", "modulename": "pyLattice.lattice", "qualname": "Lattice.find_point_on_lattice_surface", "kind": "function", "doc": "<p>Find points on the surface of the lattice</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>surfaceNames: list[str]\n    List of surfaces to find points on (e.g., [\"Xmin\", \"Xmax\", \"Ymin\"])</p>\n\n<p>surface_cells: list[str], optional\n    List of surfaces to find points on cells (e.g., [\"Xmin\", \"Xmax\", \"Ymin\"]). If None, use surfaceNames.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>pointSet: set of point objects\n    Set of points found on the specified surfaces</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">surfaceNames</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">surface_cells</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_cells_on_surfaces", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_cells_on_surfaces", "kind": "function", "doc": "<p>Return the list of Cell objects matching ordered extrema constraints like [\"Xmin\"], [\"Xmin\",\"Zmax\"], etc.\nFiltering is iterative: e.g., first keep all cells at X minimum, then among those keep Z maximum.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>surfaces : list[str]\n    Each item is one of {\"Xmin\",\"Xmax\",\"Ymin\",\"Ymax\",\"Zmin\",\"Zmax\"} (case-insensitive).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>list\n    List of Cell objects (possibly multiple if several share the same extreme index).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">surfaces</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.print_statistics_lattice", "modulename": "pyLattice.lattice", "qualname": "Lattice.print_statistics_lattice", "kind": "function", "doc": "<p>Print statistics about the lattice</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.delete_orphan_points", "modulename": "pyLattice.lattice", "qualname": "Lattice.delete_orphan_points", "kind": "function", "doc": "<p>Delete points that are not connected to any beam in the lattice.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.merge_degree2_nodes", "modulename": "pyLattice.lattice", "qualname": "Lattice.merge_degree2_nodes", "kind": "function", "doc": "<p>Fusion of nodes with exactly 2 connected beams.\nThe two beams must be colinear (if colinear_only=True) and the node must be between the two beam endpoints.\nThe two beams are replaced by a single beam connecting the two distant endpoints.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>colinear_only : bool\n    If True, only merge if the two beams are colinear.</p>\n\n<p>radius_strategy : str\n    Strategy for determining the radius of the new beam:\n    \"inherit\" (default) - if both beams have the same radius, use it; otherwise use b1's radius.\n    \"max\" - use the maximum radius of the two beams.\n    \"min\" - use the minimum radius of the two beams.\n    \"avg\" - use the average radius of the two beams.</p>\n\n<p>type_strategy : str\n    Strategy for determining the type of the new beam:\n    \"inherit\" (default) - if both beams have the same type, use it; otherwise use b1's type.\n    \"max\" - use the maximum type of the two beams.\n    \"min\" - use the minimum type of the two beams.\n    \"avg\" - use the average type of the two beams (rounded).</p>\n\n<p>material_strategy : str\n    Strategy for determining the material of the new beam:\n    \"inherit\" (default) - if both beams have the same material, use it; otherwise use b1's material.\n    \"max\" - use the maximum material of the two beams.\n    \"min\" - use the minimum material of the two beams.\n    \"avg\" - use the average material of the two beams (rounded).</p>\n\n<p>iterative : bool\n    If True, repeat the merging process until no more merges are possible or max_passes is reached.</p>\n\n<p>max_passes : int\n    Maximum number of passes if iterative is True.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>total_merged : int\n    Total number of nodes merged.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">colinear_only</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">radius_strategy</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;inherit&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">type_strategy</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;inherit&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">material_strategy</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;inherit&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">iterative</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">max_passes</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.delete_unconnected_beams", "modulename": "pyLattice.lattice", "qualname": "Lattice.delete_unconnected_beams", "kind": "function", "doc": "<p>Delete beams that are \"leaf\" beams, i.e. connected to at least one node of degree 1 or 0.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>protect_fixed: bool\n    If True, do not delete beams connected to fixed nodes.</p>\n\n<p>protect_loaded: bool\n    If True, do not delete beams connected to loaded nodes.</p>\n\n<p>also_delete_orphan_nodes: bool\n    If True, delete nodes that become orphaned after beam removal.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple[int, int]\n    Number of beams removed and number of nodes removed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">protect_fixed</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">protect_loaded</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">also_delete_orphan_nodes</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.generate_mesh_lattice_Gmsh", "modulename": "pyLattice.lattice", "qualname": "Lattice.generate_mesh_lattice_Gmsh", "kind": "function", "doc": "<p>Generate a 2D mesh representation of the lattice structure using GMSH.\nGenerating 3D mesh for simulation is not currently supported, but will be in the future.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>cut_mesh_at_boundary: bool\n    If True, the mesh will be cut at the boundary of the lattice.</p>\n\n<p>mesh_refinement: float\n    Refinement factor for the mesh (higher values lead to finer meshes).</p>\n\n<p>name_mesh: str\n    Name of the mesh to be generated.</p>\n\n<p>save_mesh: bool\n    If True, the mesh will be saved to a file.</p>\n\n<p>save_STL: bool\n    If True, the mesh will be saved in STL format.</p>\n\n<p>volume_computation: bool\n    If True, the volume of the mesh will be computed and printed.</p>\n\n<p>only_volume: bool\n    If True, only the volume of the mesh will be computed and returned.</p>\n\n<p>only_relative_density: bool\n    If True, only the relative density of the mesh will be computed and returned.</p>\n\n<p>cell_index: int | None\n    If provided, only the specified cell will be meshed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cut_mesh_at_boundary</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">mesh_refinement</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">name_mesh</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Lattice&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">save_mesh</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">save_STL</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">volume_computation</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">only_volume</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">only_relative_density</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">cell_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_volume_mesh", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_volume_mesh", "kind": "function", "doc": "<p>Compute the exact CAD volume (OCC 'mass' with unit density) of the current model\nwithout requiring any meshing.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>entities_3d : list[(int,int)] | None\n    Optional list of 3D OCC entities (pairs (dim=3, tag)). If None, all 3D\n    entities in the current model are used.</p>\n\n<p>synchronize : bool\n    If True, call gmsh.model.occ.synchronize() before querying mass properties.\n    Set to False only if you've already synchronized after your boolean ops.</p>\n\n<p>return_details : bool\n    If True, return a dict with 'total' and 'per_entity' (list of (tag, volume)).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float | dict\n    Total volume if return_details is False, else a dict:\n    {'total': float, 'per_entity': [(tag:int, volume:float), ...]}</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">entities_3d</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">synchronize</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">return_details</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.lattice.Lattice.get_relative_density_mesh", "modulename": "pyLattice.lattice", "qualname": "Lattice.get_relative_density_mesh", "kind": "function", "doc": "<p>Compute relative density = V_solid / V_domain using exact CAD volumes.</p>\n\n<p>If domain_volume is None, the domain is taken as the axis-aligned box\ndefined by (x_min..x_max) \u00d7 (y_min..y_max) \u00d7 (z_min..z_max).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">solids_3d</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">domain_volume</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.materials", "modulename": "pyLattice.materials", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyLattice.materials.MatProperties", "modulename": "pyLattice.materials", "qualname": "MatProperties", "kind": "class", "doc": "<p>A class to represent the properties of a material loaded from a file.</p>\n"}, {"fullname": "pyLattice.materials.MatProperties.__init__", "modulename": "pyLattice.materials", "qualname": "MatProperties.__init__", "kind": "function", "doc": "<p>Initialize the MatProperties object by loading data from a file.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>name_material : str\n    The name of the material to load (without file extension).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name_material</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "pyLattice.materials.MatProperties.project_root", "modulename": "pyLattice.materials", "qualname": "MatProperties.project_root", "kind": "variable", "doc": "<p></p>\n", "default_value": "PosixPath(&#x27;/home/thomas/pyLattice&#x27;)"}, {"fullname": "pyLattice.materials.MatProperties.MATERIALS_DIR", "modulename": "pyLattice.materials", "qualname": "MatProperties.MATERIALS_DIR", "kind": "variable", "doc": "<p></p>\n", "default_value": "PosixPath(&#x27;/home/thomas/pyLattice/src/pyLattice/materials&#x27;)"}, {"fullname": "pyLattice.materials.MatProperties.name_material", "modulename": "pyLattice.materials", "qualname": "MatProperties.name_material", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.materials.MatProperties.density", "modulename": "pyLattice.materials", "qualname": "MatProperties.density", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.materials.MatProperties.young_modulus", "modulename": "pyLattice.materials", "qualname": "MatProperties.young_modulus", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.materials.MatProperties.poisson_ratio", "modulename": "pyLattice.materials", "qualname": "MatProperties.poisson_ratio", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.materials.MatProperties.plastic", "modulename": "pyLattice.materials", "qualname": "MatProperties.plastic", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.materials.MatProperties.file_path", "modulename": "pyLattice.materials", "qualname": "MatProperties.file_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.materials.MatProperties.load_material", "modulename": "pyLattice.materials", "qualname": "MatProperties.load_material", "kind": "function", "doc": "<p>Loads material properties from a JSON file.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Material name_lattice, density, elastic properties, and plastic properties</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.plotting_lattice", "modulename": "pyLattice.plotting_lattice", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting", "kind": "class", "doc": "<p>Class for visualizing lattice structures in 3D.</p>\n"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.__init__", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">initFig</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.fig", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.fig", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.ax", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.ax", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.minAxis", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.minAxis", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.maxAxis", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.maxAxis", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.initFig", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.initFig", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.axisSet", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.axisSet", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.init_figure", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.init_figure", "kind": "function", "doc": "<p>Initialize the 3D figure for plotting.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.visualize_lattice", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.visualize_lattice", "kind": "function", "doc": "<p>Visualizes the lattice in 3D using matplotlib.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>lattice_object: Lattice\n    The lattice object to visualize.</p>\n\n<p>beam_color_type: str, optional (default: \"radii\")\n    Color scheme for beams. Options:\n    - \"radii\" or \"radius\": Color by radii.\n    - \"material\": Color by material.\n    - \"type\": Color by type_beam.</p>\n\n<p>deformed_form: bool, optional (default: False)\n    If True, use deformed node positions.</p>\n\n<p>file_save_path: str, optional\n    If provided, save the plot with this file path.</p>\n\n<p>cell_index: bool, optional (default: False)\n    If True, plot cell indices.</p>\n\n<p>node_index: bool, optional (default: False)\n    If True, plot node indices.</p>\n\n<p>domain_decomposition_simulation_plotting: bool, optional (default: False)\n    If True, indicates that the lattice is part of a domain decomposition simulation.</p>\n\n<p>enable_system_coordinates: bool, optional (default: True)\n    If True, plot the coordinate system axes.</p>\n\n<p>enable_boundary_conditions: bool, optional (default: False)\n    If True, visualize boundary conditions on nodes.</p>\n\n<p>camera_position: Tuple[float, float], optional\n    If provided, set the camera position for the 3D plot as (elevation, azimuth).</p>\n\n<p>plotting: bool, optional (default: True)\n    If True, display the plot after creation.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">lattice_object</span>,</span><span class=\"param\">\t<span class=\"n\">beam_color_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;radii&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">deformed_form</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">file_save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cell_index</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">node_index</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">domain_decomposition_simulation_plotting</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">enable_system_coordinates</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">enable_boundary_conditions</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">camera_position</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">plotting</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.visualize_lattice_voxels", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.visualize_lattice_voxels", "kind": "function", "doc": "<p>Visualizes the lattice in voxel mode.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>lattice_object: Lattice\n    The lattice object to visualize.</p>\n\n<p>beam_color_type: str, optional (default: \"Material\")\n    Color scheme for voxels. Options:\n    - \"Material\": Color by material.\n    - \"Type\": Color by type_beam.\n    - \"radii\": Color by radii.</p>\n\n<p>explode_voxel: float, optional (default: 0.0)\n    Amount to offset voxels for better visibility.</p>\n\n<p>cell_index: bool, optional (default: False)\n    If True, plot cell indices.</p>\n\n<p>use_radius_grad_color: bool, optional (default: False)\n    If True, color voxels based on a gradient of their radii.</p>\n\n<p>enable_system_coordinates: bool, optional (default: True)\n    If True, plot the coordinate system axes.</p>\n\n<p>camera_position: Tuple[float, float], optional\n    If provided, set the camera position for the 3D plot as (elevation,\n    azimuth).</p>\n\n<p>file_save_path: str, optional\n    If provided, save the plot with this file path.</p>\n\n<p>plotting: bool, optional (default: True)\n    If True, display the plot after creation.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">lattice_object</span>,</span><span class=\"param\">\t<span class=\"n\">beam_color_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;material&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">explode_voxel</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">cell_index</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">enable_system_coordinates</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">camera_position</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">file_save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">plotting</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.visual_cell_zone_blocker", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.visual_cell_zone_blocker", "kind": "function", "doc": "<p>Visualize the lattice with erased parts</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>eraser_blocks: list of tuple\n    List of erased parts with (x_start, y_start, z_start, x_dim, y_dim</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">lattice</span>, </span><span class=\"param\"><span class=\"n\">erasedParts</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.plot_radius_distribution", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.plot_radius_distribution", "kind": "function", "doc": "<p>Plot the radii distribution of beams in the lattice.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>lattice_object: Lattice\n    The lattice object containing the cells and beams.</p>\n\n<p>nb_radius_bins: int, optional (default: 5)\n    Number of bins to use for the histogram.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">lattice_object</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">lattice</span><span class=\"o\">.</span><span class=\"n\">Lattice</span>,</span><span class=\"param\">\t<span class=\"n\">nb_radius_bins</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.plotting_lattice.LatticePlotting.subplot_lattice_hybrid_geometries", "modulename": "pyLattice.plotting_lattice", "qualname": "LatticePlotting.subplot_lattice_hybrid_geometries", "kind": "function", "doc": "<p>Create subplots for each geometry in a hybrid lattice structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">lattice</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">lattice</span><span class=\"o\">.</span><span class=\"n\">Lattice</span>, </span><span class=\"param\"><span class=\"n\">explode_voxel</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point", "modulename": "pyLattice.point", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyLattice.point.Point", "modulename": "pyLattice.point", "qualname": "Point", "kind": "class", "doc": "<p>Represents a point in 3D space with additional attributes for simulation.</p>\n"}, {"fullname": "pyLattice.point.Point.__init__", "modulename": "pyLattice.point", "qualname": "Point.__init__", "kind": "function", "doc": "<p>Initialize a point object.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : float\n    X-coordinate of the point.</p>\n\n<p>y : float\n    Y-coordinate of the point.</p>\n\n<p>z : float\n    Z-coordinate of the point.</p>\n\n<p>cell_belongings : List[Cell]\n    List of cells that contain this point.</p>\n\n<p>node_uncertainty_SD : float, optional\n    Standard deviation for node position uncertainty (default is 0.0).</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If coordinates are not numeric or if node_uncertainty_SD is negative.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">z</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">cell_belongings</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">cell</span><span class=\"o\">.</span><span class=\"n\">Cell</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">node_uncertainty_SD</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span></span>)</span>"}, {"fullname": "pyLattice.point.Point.x", "modulename": "pyLattice.point", "qualname": "Point.x", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "pyLattice.point.Point.y", "modulename": "pyLattice.point", "qualname": "Point.y", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "pyLattice.point.Point.z", "modulename": "pyLattice.point", "qualname": "Point.z", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "pyLattice.point.Point.cell_belongings", "modulename": "pyLattice.point", "qualname": "Point.cell_belongings", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[pyLattice.cell.Cell]"}, {"fullname": "pyLattice.point.Point.connected_beams", "modulename": "pyLattice.point", "qualname": "Point.connected_beams", "kind": "variable", "doc": "<p></p>\n", "annotation": ": set"}, {"fullname": "pyLattice.point.Point.index", "modulename": "pyLattice.point", "qualname": "Point.index", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[int]"}, {"fullname": "pyLattice.point.Point.tag", "modulename": "pyLattice.point", "qualname": "Point.tag", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[int]"}, {"fullname": "pyLattice.point.Point.cell_local_tag", "modulename": "pyLattice.point", "qualname": "Point.cell_local_tag", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dict]"}, {"fullname": "pyLattice.point.Point.index_boundary", "modulename": "pyLattice.point", "qualname": "Point.index_boundary", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[int]"}, {"fullname": "pyLattice.point.Point.displacement_vector", "modulename": "pyLattice.point", "qualname": "Point.displacement_vector", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[float]"}, {"fullname": "pyLattice.point.Point.reaction_force_vector", "modulename": "pyLattice.point", "qualname": "Point.reaction_force_vector", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[float]"}, {"fullname": "pyLattice.point.Point.applied_force", "modulename": "pyLattice.point", "qualname": "Point.applied_force", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[float]"}, {"fullname": "pyLattice.point.Point.fixed_DOF", "modulename": "pyLattice.point", "qualname": "Point.fixed_DOF", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[bool]"}, {"fullname": "pyLattice.point.Point.global_free_DOF_index", "modulename": "pyLattice.point", "qualname": "Point.global_free_DOF_index", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[Optional[float]]"}, {"fullname": "pyLattice.point.Point.node_mod", "modulename": "pyLattice.point", "qualname": "Point.node_mod", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "pyLattice.point.Point.magnification_factor", "modulename": "pyLattice.point", "qualname": "Point.magnification_factor", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "pyLattice.point.Point.destroy", "modulename": "pyLattice.point", "qualname": "Point.destroy", "kind": "function", "doc": "<p>Remove all references to this point from connected beams and cells.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.coordinates", "modulename": "pyLattice.point", "qualname": "Point.coordinates", "kind": "variable", "doc": "<p>Retrieve the current position of the point.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>Tuple[float, float, float]: (x, y, z) coordinates of the point.\n</code></pre>\n", "annotation": ": Tuple[float, float, float]"}, {"fullname": "pyLattice.point.Point.data", "modulename": "pyLattice.point", "qualname": "Point.data", "kind": "variable", "doc": "<p>Retrieve point data for exporting.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>List[float]: [index, x, y, z] of the point.\n</code></pre>\n", "annotation": ": List[float]"}, {"fullname": "pyLattice.point.Point.deformed_coordinates", "modulename": "pyLattice.point", "qualname": "Point.deformed_coordinates", "kind": "variable", "doc": "<p>Retrieve the deformed position of the point.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>Tuple[float, float, float]: (x, y, z) coordinates including displacements.\n</code></pre>\n", "annotation": ": Tuple[float, float, float]"}, {"fullname": "pyLattice.point.Point.move_to", "modulename": "pyLattice.point", "qualname": "Point.move_to", "kind": "function", "doc": "<p>Move the point to new coordinates.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>xNew : float\n    New x-coordinate.</p>\n\n<p>yNew : float\n    New y-coordinate.</p>\n\n<p>zNew : float\n    New z-coordinate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xNew</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">yNew</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">zNew</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.tag_point", "modulename": "pyLattice.point", "qualname": "Point.tag_point", "kind": "function", "doc": "<p>Generate standardized tags for the point based on its position.\nCheck : <a href=\"https://docs.fenicsproject.org/basix/v0.2.0/index.html\">https://docs.fenicsproject.org/basix/v0.2.0/index.html</a> for more informations</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>boundary_box_domain : List[float]\n    Boundary box domain containing [x_min, x_max, y_min, y_max, z_min, z_max].</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>int\n    tag of the point</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">boundary_box_domain</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.is_identical_to", "modulename": "pyLattice.point", "qualname": "Point.is_identical_to", "kind": "function", "doc": "<p>Check if this point is identical to another point, modulo the cell size (periodicity).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>other : Point\n    The other point to compare with.</p>\n\n<p>cell_size : list[float]\n    Size of the unit cell in x, y, z directions.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>bool\n    True if the points are identical modulo the cell size, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>, </span><span class=\"param\"><span class=\"n\">cell_size</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.is_on_boundary", "modulename": "pyLattice.point", "qualname": "Point.is_on_boundary", "kind": "function", "doc": "<p>Get boolean that give information of boundary node</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>boundary_box_lattice: list[float]\n    Boundary box of the lattice containing [x_min, x_max, y_min, y_max, z_min, z_max].</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>boolean: (True if node on boundary)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">boundary_box_lattice</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.distance_to", "modulename": "pyLattice.point", "qualname": "Point.distance_to", "kind": "function", "doc": "<p>Calculate the distance to another point.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>other : Point\n    The other point to calculate the distance to.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>float\n    The Euclidean distance between this point and the other point.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.set_local_tag", "modulename": "pyLattice.point", "qualname": "Point.set_local_tag", "kind": "function", "doc": "<p>Set the local tag for a specific cell containing the point.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>cell_index : int\n    Index of the cell.\nlocal_tag : int\n    Local tag to assign to the point for the specified cell.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cell_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">local_tag</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.add_cell_belonging", "modulename": "pyLattice.point", "qualname": "Point.add_cell_belonging", "kind": "function", "doc": "<p>Add a cell to the list of cells containing this point.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>cell : Cell\n    The cell to add.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cell</span><span class=\"p\">:</span> <span class=\"n\">pyLattice</span><span class=\"o\">.</span><span class=\"n\">cell</span><span class=\"o\">.</span><span class=\"n\">Cell</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.initialize_reaction_force", "modulename": "pyLattice.point", "qualname": "Point.initialize_reaction_force", "kind": "function", "doc": "<p>Reset the reaction force vector to zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.initialize_displacement", "modulename": "pyLattice.point", "qualname": "Point.initialize_displacement", "kind": "function", "doc": "<p>Reset displacement values to zero for all DOF.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.set_applied_force", "modulename": "pyLattice.point", "qualname": "Point.set_applied_force", "kind": "function", "doc": "<p>Assign applied force to the point.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>appliedForce : List[float]\n    Applied force values for each DOF.</p>\n\n<p>DOF : list[int]\n    List of DOF to assign (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">appliedForce</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">DOF</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.set_reaction_force", "modulename": "pyLattice.point", "qualname": "Point.set_reaction_force", "kind": "function", "doc": "<p>Assign reaction force to the point.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>reactionForce : List[float]\n    Reaction force values for each DOF.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">reactionForce</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.fix_DOF", "modulename": "pyLattice.point", "qualname": "Point.fix_DOF", "kind": "function", "doc": "<p>Fix specific degrees of freedom for the point.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>DOF : List[int]\n    List of DOF to fix (0: x, 1: y, 2: z, 3: Rx, 4: Ry, 5: Rz).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">DOF</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.point.Point.calculate_point_energy", "modulename": "pyLattice.point", "qualname": "Point.calculate_point_energy", "kind": "function", "doc": "<p>Calculate the internal energy of the point.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>float\n    The internal energy of the point.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.timing", "modulename": "pyLattice.timing", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyLattice.timing.Timing", "modulename": "pyLattice.timing", "qualname": "Timing", "kind": "class", "doc": "<p>General-purpose timing &amp; call-graph collector.</p>\n"}, {"fullname": "pyLattice.timing.Timing.timings", "modulename": "pyLattice.timing", "qualname": "Timing.timings", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.timing.Timing.call_stack", "modulename": "pyLattice.timing", "qualname": "Timing.call_stack", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.timing.Timing.call_graph", "modulename": "pyLattice.timing", "qualname": "Timing.call_graph", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.timing.Timing.call_counts", "modulename": "pyLattice.timing", "qualname": "Timing.call_counts", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.timing.Timing.local", "modulename": "pyLattice.timing", "qualname": "Timing.local", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.timing.Timing.func_category", "modulename": "pyLattice.timing", "qualname": "Timing.func_category", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyLattice.timing.Timing.category", "modulename": "pyLattice.timing", "qualname": "Timing.category", "kind": "function", "doc": "<p>Decorator to tag functions with a category (e.g., 'sim', 'mesh', 'io').\nUse together with @timeit to enable grouped summaries.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">label</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.timing.Timing.timeit", "modulename": "pyLattice.timing", "qualname": "Timing.timeit", "kind": "function", "doc": "<p>Decorator to time execution and populate timings + call graph.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.timing.Timing.reset", "modulename": "pyLattice.timing", "qualname": "Timing.reset", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.timing.Timing.summary", "modulename": "pyLattice.timing", "qualname": "Timing.summary", "kind": "function", "doc": "<p>Print a filtered, aligned summary with truncated names.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>classes : Optional[Iterable[str]]\n    If provided, only include functions whose qualified names start with one of these class names.</p>\n\n<p>name_pattern : Optional[str]\n    If provided, only include functions whose qualified names match this regex pattern.</p>\n\n<p>max_depth : Optional[int]\n    If provided, only include functions up to this depth in the call graph.</p>\n\n<p>min_total : float\n    Minimum total time (in seconds) to include a function in the report.</p>\n\n<p>top_n : Optional[int]\n    If provided, only include the top N functions by total time.</p>\n\n<p>print_children : bool\n    If True, print child functions under each parent in the call graph.</p>\n\n<p>name_width : int\n    Maximum width for function names; longer names will be truncated with an ellipsis.</p>\n\n<p>group_by_category : bool\n    If True, group functions by their assigned category (using the @category decorator).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">classes</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">name_pattern</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_depth</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">min_total</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">top_n</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">print_children</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">name_width</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">40</span>,</span><span class=\"param\">\t<span class=\"n\">group_by_category</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.timing.timing", "modulename": "pyLattice.timing", "qualname": "timing", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;pyLattice.timing.Timing object&gt;"}, {"fullname": "pyLattice.utils", "modulename": "pyLattice.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyLattice.utils.open_lattice_parameters", "modulename": "pyLattice.utils", "qualname": "open_lattice_parameters", "kind": "function", "doc": "<p>Open a JSON file containing lattice parameters.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>file_name: str\n    Name of the JSON file containing lattice parameters.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.utils.save_lattice_object", "modulename": "pyLattice.utils", "qualname": "save_lattice_object", "kind": "function", "doc": "<p>Save ONLY the base <code>Lattice</code> state to a pickle, even if <code>lattice</code> is an instance\nof a subclass (e.g., LatticeSim/LatticeOpti) carrying non-picklable fields.</p>\n\n<p>Important: converts internal sets (beams/nodes and per-cell containers) to lists\nbefore pickling to avoid hashing during unpickling. A marker <code>_pickle_format</code>\nis stored so the loader can restore sets later.\nNote: this function does NOT save the full state of subclasses, only the base\n<code>Lattice</code> attributes. (TO UPDATE if needed)</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>lattice: Lattice\n    Lattice object to save.</p>\n\n<p>file_name: str\n    Name of the pickle file to save.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lattice</span>, </span><span class=\"param\"><span class=\"n\">file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;LatticeObject&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.utils.save_JSON_to_Grasshopper", "modulename": "pyLattice.utils", "qualname": "save_JSON_to_Grasshopper", "kind": "function", "doc": "<p>Save the current lattice object to JSON files for Grasshopper compatibility, separating by cells.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>lattice: Lattice\n    Lattice object to save.</p>\n\n<p>nameLattice: str\n    Name of the lattice file to save.</p>\n\n<p>multipleParts: int, optional (default: 1)\n    Number of parts to save.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">lattice</span>,</span><span class=\"param\">\t<span class=\"n\">nameLattice</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;LatticeObject&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">multipleParts</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.utils.function_penalization_Lzone", "modulename": "pyLattice.utils", "qualname": "function_penalization_Lzone", "kind": "function", "doc": "<p>Calculate the penalization length based on radii and angle.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>radius: float\n    Radius of the beam.</p>\n\n<p>angle: float\n    Angle in degrees.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>float: Length of the penalization zone.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.utils.get_boundary_condition_color", "modulename": "pyLattice.utils", "qualname": "get_boundary_condition_color", "kind": "function", "doc": "<p>Generate a color based on the fixed DOFs using a bitmask approach.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fixed_DOF</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "pyLattice.utils.plot_coordinate_system", "modulename": "pyLattice.utils", "qualname": "plot_coordinate_system", "kind": "function", "doc": "<p>Plot a 3D coordinate system with arrows representing the X, Y, and Z axes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();